#' take an sf object polygon and make a grid out of it
#' 
#' @param viz a vizlab object including a \code{cell_size} parameter input
#' and a polygon or multipolygon \code{mask_poly}
#' @details
#' \code{mask_poly} is the polygon or multipolygon that defines the coverage of
#' the grid that will be constructed. The \code{cell_size} input 
#' (in units of the \code{mask_poly} projection) determine the resolution of the grid.
#' The cell grid is clipped to the mask generated by dissolving features of \code{mask_poly} 
#' into a single feature (e.g., getting rid of state borders)
process.cells_from_mask <- function(viz){
  deps <- readDepends(viz)
  checkRequired(viz, c("cell_size"))
  
  mask_poly <- deps[['mask_poly']]
  crs <- sf::st_crs(mask_poly)
  cell_size <- viz[["cell_size"]]
  
  # this is a simple way to dissolve multiple polygons into a single mask
  clip_mask <- mask_poly %>% st_buffer(dist = 0) %>% 
    mutate(group='mask') %>% group_by(group) %>% summarise()
  cell_grid <- sf::st_make_grid(clip_mask, cellsize = cell_size, crs = crs)
  cell_grid_clipped <- sf::st_intersection(cell_grid, clip_mask)
  
  # add an id to be used for adding data later:
  cell_grid_clipped <- st_sf(cell_grid_clipped, row.names = paste('cell_', 1:length(cell_grid_clipped), sep= ''))
  saveRDS(cell_grid_clipped, file = viz[['location']])
}